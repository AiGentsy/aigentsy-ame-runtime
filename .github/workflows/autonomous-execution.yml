# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AiGentsy Autonomous Execution Workflow v4 - POST 77-FILE AUDIT
# Updated: January 2, 2026
# Based on COMPLETE surgical audit of 77 files (~95,000 lines)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# CHANGES FROM v3:
# - Updated file count: 77 files (was 26)
# - Added 15 NEW systems discovered in audit
# - Added new endpoints for full coverage
# - Added arbitrage execution pipeline
# - Added AIGx protocol integration
# - Added deal graph relationship tracking
# - Added real-world proof verification
# - Graceful degradation for missing endpoints
#
# COMPLETE SYSTEMS ORCHESTRATED (143+ subsystems):
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 
# DISCOVERY LAYER:
#   1. ultimate_discovery_engine - 27+ platforms (Upwork, Fiverr, GitHub, Reddit, HN, Twitter, etc.)
#   2. advanced_discovery_dimensions - 7 dimensions (predictive, network, creation, emergent)
#   3. real_signal_ingestion - Funding, launches, regulatory, tech deprecations
#   4. opportunity_filters - P95 outlier detection, staleness, skip logic
#
# ROUTING & SCORING:
#   5. csuite_orchestrator - C-Suite business intelligence
#   6. opportunity_scoring - Score calculation across dimensions
#   7. opportunity_approval - User approval workflow
#   8. execution_routes - Route to user queue or AiGentsy fulfillment
#
# BIDDING & OUTREACH:
#   9. auto_bidding_orchestrator - Multi-platform bid submission
#   10. opportunity_engagement - Platform-specific outreach templates
#   11. ame_pitches - AME pitch generation
#   12. social_autoposting_engine - Cross-platform social posting
#
# FULFILLMENT:
#   13. graphics_fulfillment_engine - Stable Diffusion, DALL-E 3
#   14. video_engine - Runway ML, Synthesia, HeyGen
#   15. audio_engine - ElevenLabs, Murf, Play.ht
#   16. claude_code_fulfillment - Code generation
#   17. openrouter_agent_helper - Multi-AI coordination
#
# VERIFICATION:
#   18. deliverable_verification_engine - 5-dimension semantic QA
#   19. proof_pipe - Real-world outcome proofs (Square, Calendly webhooks)
#
# PAYMENT & REVENUE:
#   20. escrow_lite - Stripe payment intents
#   21. revenue_flows - Multi-channel revenue tracking
#   22. batch_payments - Bulk agent payments
#   23. agent_factoring - Immediate advances
#   24. pwp_engine - Pay-with-performance financing
#
# FINANCIAL:
#   25. ocl_engine - Operating Credit Line (P2P)
#   26. ipvault - IP royalty automation
#   27. franchise_engine - Template licensing
#   28. sponsor_pools - External capital subsidies
#
# LEARNING:
#   29. yield_memory - Cross-AI learning
#   30. metahive_brain - Collective intelligence
#   31. autonomous_deal_graph - Relationship tracking
#   32. client_success_predictor - Churn prediction
#
# PROTOCOL:
#   33. aigx_protocol - AI-to-AI economic protocol
#   34. open_metahive_api - External system integration
#   35. slo_tiers - Service level guarantees
#
# ARBITRAGE:
#   36. flow_arbitrage_detector - Price/temporal/supply arbitrage detection
#   37. arbitrage_execution_pipeline - Auto-purchase â†’ fulfill â†’ list â†’ settle
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# VERIFIED ENDPOINTS (from main.py audit):
# âœ… POST /mint - User signup with auto-discovery
# âœ… GET /opportunities/{username} - Get scored opportunities
# âœ… POST /social/process-queue - Process social posts
# âœ… POST /autonomous/full-cycle - Full arbitrage + signals + intros
# âœ… POST /webhook/stripe - Stripe webhook handler
# âœ… GET /execution/health/detail - Detailed health
# âœ… POST /wade/discover-and-queue - Discovery + queue
#
# ENDPOINTS TO BE ADDED (see main.py gap analysis):
# âš ï¸ POST /autonomous/discover-and-execute - Full discovery + execution
# âš ï¸ GET /autonomous/stats - Queue statistics
# âš ï¸ GET /autonomous/approval-queue - Pending approvals
# âš ï¸ GET /execution/stats - Execution statistics
# âš ï¸ GET /execution/health - Simple health check
# âš ï¸ POST /execution/discover-and-route - Route opportunities
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: AiGentsy Autonomous Execution v4

on:
  # Run every hour at minute 0
  schedule:
    - cron: '0 * * * *'
  
  # Manual trigger with full options
  workflow_dispatch:
    inputs:
      mode:
        description: 'Execution mode'
        required: false
        default: 'full'
        type: choice
        options:
          - full              # All systems
          - discovery_only    # Just discovery + routing
          - social_only       # Just social posting
          - health_only       # Just health checks
          - queue_review      # Show all queues
          - ame_pitches       # Process AME pitch queue
          - arbitrage_only    # Just arbitrage execution
          - signals_only      # Just signal ingestion
      auto_approve_user:
        description: 'Auto-approve user opportunities (>60% win prob)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      auto_approve_aigentsy:
        description: 'Auto-approve AiGentsy opportunities (>80% win prob)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      max_executions:
        description: 'Max opportunities to execute per run'
        required: false
        default: '10'
      min_win_probability:
        description: 'Minimum win probability for autonomous (0.0-1.0)'
        required: false
        default: '0.7'
      run_arbitrage:
        description: 'Run arbitrage detection and execution'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  BACKEND_URL: ${{ secrets.BACKEND_URL || 'https://aigentsy-ame-runtime.onrender.com' }}

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: DISCOVERY & EXECUTION
  # Scan 27+ platforms, route opportunities, execute approved ones
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  discovery:
    name: ğŸ” Discovery & Execution
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode != 'social_only' && github.event.inputs.mode != 'health_only' && github.event.inputs.mode != 'queue_review' && github.event.inputs.mode != 'arbitrage_only' && github.event.inputs.mode != 'signals_only' }}
    outputs:
      total_discovered: ${{ steps.discover.outputs.total_discovered }}
      total_executed: ${{ steps.discover.outputs.total_executed }}
      total_value: ${{ steps.discover.outputs.total_value }}
      user_routed: ${{ steps.discover.outputs.user_routed }}
      aigentsy_routed: ${{ steps.discover.outputs.aigentsy_routed }}
    
    steps:
      - name: ğŸš€ Run Autonomous Discovery & Execution
        id: discover
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” AUTONOMOUS DISCOVERY ENGINE v4 - 27+ PLATFORMS"
          echo "   Based on 77-file audit (~95,000 lines of code)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "âš™ï¸  Configuration:"
          echo "   Backend: ${{ env.BACKEND_URL }}"
          echo "   Auto-approve user: ${{ github.event.inputs.auto_approve_user || 'true' }}"
          echo "   Auto-approve AiGentsy: ${{ github.event.inputs.auto_approve_aigentsy || 'false' }}"
          echo "   Max executions: ${{ github.event.inputs.max_executions || '10' }}"
          echo "   Min win probability: ${{ github.event.inputs.min_win_probability || '0.7' }}"
          echo ""
          
          # Build request body
          REQUEST_BODY=$(cat <<EOF
          {
            "auto_approve_user": ${{ github.event.inputs.auto_approve_user || 'true' }},
            "auto_approve_aigentsy": ${{ github.event.inputs.auto_approve_aigentsy || 'false' }},
            "max_executions": ${{ github.event.inputs.max_executions || '10' }},
            "min_win_probability": ${{ github.event.inputs.min_win_probability || '0.7' }}
          }
          EOF
          )
          
          # Try the new endpoint first, fall back to existing
          echo "ğŸ“¡ Calling /autonomous/discover-and-execute..."
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/autonomous/discover-and-execute" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_BODY" \
            --max-time 180 2>/dev/null || echo '{"ok": false, "error": "endpoint_not_found"}')
          
          OK=$(echo "$RESPONSE" | jq -r '.ok // false')
          
          # Fallback to /autonomous/full-cycle if new endpoint doesn't exist
          if [ "$OK" = "false" ]; then
            echo "âš ï¸  New endpoint not available, falling back to /autonomous/full-cycle..."
            RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/autonomous/full-cycle" \
              -H "Content-Type: application/json" \
              --max-time 180 || echo '{"ok": false, "error": "Request timeout or failed"}')
            OK=$(echo "$RESPONSE" | jq -r '.ok // false')
          fi
          
          if [ "$OK" = "true" ]; then
            # Extract metrics - handle both response formats
            TOTAL_DISCOVERED=$(echo "$RESPONSE" | jq -r '.discovery.total_opportunities // .results.signals.opportunities_found // 0')
            TOTAL_EXECUTED=$(echo "$RESPONSE" | jq -r '.executions.count // .results.arbitrage.completed // 0')
            TOTAL_VALUE=$(echo "$RESPONSE" | jq -r '.discovery.total_value // 0')
            MESSAGE=$(echo "$RESPONSE" | jq -r '.message // "Complete"')
            
            # Routing breakdown
            USER_COUNT=$(echo "$RESPONSE" | jq -r '.discovery.routing.user_routed.count // 0')
            USER_VALUE=$(echo "$RESPONSE" | jq -r '.discovery.routing.user_routed.value // 0')
            AIGENTSY_COUNT=$(echo "$RESPONSE" | jq -r '.discovery.routing.aigentsy_routed.count // 0')
            AIGENTSY_VALUE=$(echo "$RESPONSE" | jq -r '.discovery.routing.aigentsy_routed.value // 0')
            AIGENTSY_PROFIT=$(echo "$RESPONSE" | jq -r '.discovery.routing.aigentsy_routed.estimated_profit // .results.arbitrage.total_profit // 0')
            
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âœ… DISCOVERY COMPLETE"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“Š DISCOVERY RESULTS:"
            echo "   Total Opportunities: $TOTAL_DISCOVERED"
            echo "   Total Value: \$$TOTAL_VALUE"
            echo "   Executed This Run: $TOTAL_EXECUTED"
            echo ""
            echo "ğŸ“Œ ROUTING BREAKDOWN:"
            echo "   ğŸ‘¤ User Opportunities: $USER_COUNT (\$$USER_VALUE)"
            echo "   ğŸ¤– AiGentsy Opportunities: $AIGENTSY_COUNT (\$$AIGENTSY_VALUE)"
            echo "   ğŸ’° Est. AiGentsy Profit: \$$AIGENTSY_PROFIT"
            echo ""
            echo "ğŸ’¬ $MESSAGE"
            echo ""
            
            # Set outputs for downstream jobs
            echo "total_discovered=$TOTAL_DISCOVERED" >> $GITHUB_OUTPUT
            echo "total_executed=$TOTAL_EXECUTED" >> $GITHUB_OUTPUT
            echo "total_value=$TOTAL_VALUE" >> $GITHUB_OUTPUT
            echo "user_routed=$USER_COUNT" >> $GITHUB_OUTPUT
            echo "aigentsy_routed=$AIGENTSY_COUNT" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "âš ï¸ Discovery did not complete successfully"
            ERROR=$(echo "$RESPONSE" | jq -r '.error // "Unknown error"')
            echo "Error: $ERROR"
            echo ""
            
            # Set zero outputs
            echo "total_discovered=0" >> $GITHUB_OUTPUT
            echo "total_executed=0" >> $GITHUB_OUTPUT
            echo "total_value=0" >> $GITHUB_OUTPUT
            echo "user_routed=0" >> $GITHUB_OUTPUT
            echo "aigentsy_routed=0" >> $GITHUB_OUTPUT
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: ARBITRAGE EXECUTION (NEW in v4)
  # Detect arbitrage â†’ Auto-purchase â†’ Fulfill â†’ List â†’ Collect spread
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  arbitrage:
    name: ğŸ’µ Arbitrage Execution
    runs-on: ubuntu-latest
    if: ${{ (github.event.inputs.mode == 'full' || github.event.inputs.mode == 'arbitrage_only') && github.event.inputs.run_arbitrage != 'false' }}
    
    steps:
      - name: ğŸ’µ Run Arbitrage Pipeline
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ’µ ARBITRAGE EXECUTION PIPELINE"
          echo "   Detect â†’ Purchase â†’ Fulfill â†’ List â†’ Settle"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Run full arbitrage cycle
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/arbitrage/execute" \
            -H "Content-Type: application/json" \
            -d '{"max_opportunities": 5, "min_margin": 0.20}' \
            --max-time 120 || echo '{"ok": false}')
          
          OK=$(echo "$RESPONSE" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            TOTAL=$(echo "$RESPONSE" | jq -r '.total // 0')
            COMPLETED=$(echo "$RESPONSE" | jq -r '.completed // 0')
            PROFIT=$(echo "$RESPONSE" | jq -r '.total_profit // 0')
            
            echo "âœ… ARBITRAGE RESULTS:"
            echo "   Opportunities Found: $TOTAL"
            echo "   Successfully Executed: $COMPLETED"
            echo "   Total Profit: \$$PROFIT"
          else
            echo "âš ï¸ Arbitrage endpoint not available or no opportunities"
            
            # Fallback: Try the full-cycle which includes arbitrage
            echo "   Trying /autonomous/full-cycle (includes arbitrage)..."
            FALLBACK=$(curl -s -X POST "${{ env.BACKEND_URL }}/autonomous/full-cycle" \
              --max-time 120 || echo '{}')
            ARB_PROFIT=$(echo "$FALLBACK" | jq -r '.results.arbitrage.total_profit // 0')
            echo "   Arbitrage profit from full-cycle: \$$ARB_PROFIT"
          fi
          echo ""

      - name: ğŸ“Š Arbitrage Statistics
        run: |
          echo "ğŸ“Š ARBITRAGE STATS:"
          STATS=$(curl -s -X GET "${{ env.BACKEND_URL }}/arbitrage/stats" --max-time 15 || echo '{}')
          
          TOTAL=$(echo "$STATS" | jq -r '.stats.total_executions // 0')
          COMPLETED=$(echo "$STATS" | jq -r '.stats.completed // 0')
          PROFIT=$(echo "$STATS" | jq -r '.stats.total_profit // 0')
          AVG_ROI=$(echo "$STATS" | jq -r '.stats.avg_roi // 0')
          
          echo "   Total Executions: $TOTAL"
          echo "   Completed: $COMPLETED"
          echo "   Total Profit: \$$PROFIT"
          echo "   Avg ROI: ${AVG_ROI}%"
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: SIGNAL INGESTION (NEW in v4)
  # Ingest real-world signals for predictive opportunities
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  signals:
    name: ğŸ“¡ Signal Ingestion
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'full' || github.event.inputs.mode == 'signals_only' }}
    
    steps:
      - name: ğŸ“¡ Ingest Real-World Signals
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“¡ REAL-WORLD SIGNAL INGESTION"
          echo "   Funding events, launches, regulatory, tech deprecations"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # This calls the signal ingestion via full-cycle
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/autonomous/full-cycle" \
            -H "Content-Type: application/json" \
            --max-time 120 || echo '{"ok": false}')
          
          SIGNALS=$(echo "$RESPONSE" | jq -r '.results.signals // {}')
          
          if [ "$SIGNALS" != "{}" ] && [ "$SIGNALS" != "null" ]; then
            FUNDING=$(echo "$SIGNALS" | jq -r '.by_source.funding // 0')
            LAUNCHES=$(echo "$SIGNALS" | jq -r '.by_source.launches // 0')
            REGULATORY=$(echo "$SIGNALS" | jq -r '.by_source.regulatory // 0')
            TECH=$(echo "$SIGNALS" | jq -r '.by_source.tech // 0')
            
            echo "âœ… SIGNALS INGESTED:"
            echo "   ğŸ’° Funding events: $FUNDING"
            echo "   ğŸš€ Product launches: $LAUNCHES"
            echo "   âš–ï¸  Regulatory changes: $REGULATORY"
            echo "   ğŸ”§ Tech deprecations: $TECH"
          else
            echo "âš ï¸ Signal ingestion not available or no signals found"
          fi
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 4: SOCIAL POSTING
  # Process scheduled social posts across platforms
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  social:
    name: ğŸ“± Social Posting
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'full' || github.event.inputs.mode == 'social_only' }}
    
    steps:
      - name: ğŸ“± Process Social Queue
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“± SOCIAL AUTO-POSTING ENGINE"
          echo "   Platforms: TikTok, Instagram, YouTube, Twitter, LinkedIn"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/social/process-queue" \
            -H "Content-Type: application/json" \
            --max-time 60 || echo '{"ok": false}')
          
          OK=$(echo "$RESPONSE" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            PROCESSED=$(echo "$RESPONSE" | jq -r '.processed // 0')
            echo "âœ… Social posts processed: $PROCESSED"
            
            # Show results by platform if available
            echo "$RESPONSE" | jq -r '.results[]? | "   \(.platform // "unknown"): \(.status // "unknown")"' 2>/dev/null || true
          else
            echo "âš ï¸ Social queue processing failed or empty"
          fi
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 5: HEALTH & MONITORING
  # Check all system health and statistics
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  health:
    name: ğŸ¥ Health Check
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'full' || github.event.inputs.mode == 'health_only' }}
    
    steps:
      - name: ğŸ¥ System Health Check
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ¥ AIGENTSY SYSTEM HEALTH CHECK"
          echo "   Checking 143+ subsystems across 77 files"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Try detailed health first
          HEALTH=$(curl -s -X GET "${{ env.BACKEND_URL }}/execution/health/detail" \
            --max-time 30 || echo '{"ok": false}')
          
          OK=$(echo "$HEALTH" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            WORKING=$(echo "$HEALTH" | jq -r '.working // 0')
            STUBS=$(echo "$HEALTH" | jq -r '.stubs // 0')
            BROKEN=$(echo "$HEALTH" | jq -r '.broken // 0')
            
            echo "âœ… SYSTEM STATUS:"
            echo "   Working: $WORKING"
            echo "   Stubs: $STUBS"
            echo "   Broken: $BROKEN"
            echo ""
            
            # Show broken systems if any
            if [ "$BROKEN" != "0" ]; then
              echo "âš ï¸ BROKEN SYSTEMS:"
              echo "$HEALTH" | jq -r '.broken_list[]? | "   - \(.)"' 2>/dev/null || true
            fi
          else
            # Fallback to simple health
            SIMPLE=$(curl -s -X GET "${{ env.BACKEND_URL }}/health" --max-time 10 || echo '{}')
            STATUS=$(echo "$SIMPLE" | jq -r '.status // "unknown"')
            echo "Basic health check: $STATUS"
          fi
          echo ""

      - name: ğŸ“Š Execution Statistics
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š EXECUTION STATISTICS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Try new stats endpoint
          STATS=$(curl -s -X GET "${{ env.BACKEND_URL }}/execution/stats" \
            --max-time 15 2>/dev/null || echo '{"ok": false}')
          
          OK=$(echo "$STATS" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            USER_PENDING=$(echo "$STATS" | jq -r '.pending.user_approvals // 0')
            WADE_PENDING=$(echo "$STATS" | jq -r '.pending.wade_approvals // 0')
            IN_PROGRESS=$(echo "$STATS" | jq -r '.in_progress // 0')
            COMPLETED=$(echo "$STATS" | jq -r '.completed // 0')
            
            echo "ğŸ“Œ APPROVAL QUEUES:"
            echo "   User approvals pending: $USER_PENDING"
            echo "   Wade approvals pending: $WADE_PENDING"
            echo ""
            echo "âš¡ EXECUTION STATUS:"
            echo "   In progress: $IN_PROGRESS"
            echo "   Completed: $COMPLETED"
          else
            echo "âš ï¸ Execution stats endpoint not available"
            echo "   (Add GET /execution/stats to main.py)"
          fi
          echo ""

      - name: ğŸ“Š Autonomous Statistics
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š AUTONOMOUS EXECUTION STATISTICS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Get autonomous stats
          STATS=$(curl -s -X GET "${{ env.BACKEND_URL }}/autonomous/stats" \
            --max-time 30 2>/dev/null || echo '{"ok": false}')
          
          OK=$(echo "$STATS" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            PENDING=$(echo "$STATS" | jq -r '.pending_count // .autonomous_queue.pending_approval // 0')
            QUEUED_VALUE=$(echo "$STATS" | jq -r '.queued_value // 0')
            
            echo "ğŸ¤– AUTONOMOUS QUEUE:"
            echo "   Pending: $PENDING"
            echo "   Queued Value: \$$QUEUED_VALUE"
          else
            echo "âš ï¸ Autonomous stats endpoint not available"
            echo "   (Add GET /autonomous/stats to main.py)"
          fi
          echo ""

      - name: ğŸ¯ APEX Upgrades Dashboard
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ¯ APEX UPGRADES DASHBOARD"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          DASHBOARD=$(curl -s -X GET "${{ env.BACKEND_URL }}/apex/upgrades/dashboard" \
            --max-time 30 2>/dev/null || echo '{"ok": false}')
          
          OK=$(echo "$DASHBOARD" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            echo "âœ… APEX Systems Status:"
            
            VERIFIED=$(echo "$DASHBOARD" | jq -r '.systems.verification.total_verified // 0')
            echo "   ğŸ“‹ Verification: $VERIFIED verified"
            
            BIDS=$(echo "$DASHBOARD" | jq -r '.systems.pricing.total_bids // 0')
            echo "   ğŸ’° Pricing: $BIDS bids"
            
            PREDICTIONS=$(echo "$DASHBOARD" | jq -r '.systems.success_prediction.total_predictions // 0')
            echo "   ğŸ¯ Success: $PREDICTIONS predictions"
            
            REVENUE=$(echo "$DASHBOARD" | jq -r '.systems.reconciliation.total_revenue // 0')
            echo "   ğŸ’µ Revenue: \$$REVENUE tracked"
          else
            echo "âš ï¸ APEX dashboard not available"
          fi
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 6: QUEUE REVIEW (Manual trigger only)
  # Show current state of all queues
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  queue_review:
    name: ğŸ“‹ Queue Review
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'queue_review' }}
    
    steps:
      - name: ğŸ“‹ Review All Queues
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“‹ QUEUE REVIEW - ALL PENDING ITEMS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Execution stats
          echo "ğŸ“Œ EXECUTION QUEUES:"
          EXEC_STATS=$(curl -s -X GET "${{ env.BACKEND_URL }}/execution/stats" --max-time 15 2>/dev/null || echo '{}')
          USER_PENDING=$(echo "$EXEC_STATS" | jq -r '.pending.user_approvals // "N/A"')
          WADE_PENDING=$(echo "$EXEC_STATS" | jq -r '.pending.wade_approvals // "N/A"')
          echo "   User approvals: $USER_PENDING"
          echo "   Wade approvals: $WADE_PENDING"
          echo ""
          
          # Autonomous queue
          echo "ğŸ¤– AUTONOMOUS QUEUE:"
          AUTO_QUEUE=$(curl -s -X GET "${{ env.BACKEND_URL }}/autonomous/approval-queue" --max-time 15 2>/dev/null || echo '{}')
          AUTO_COUNT=$(echo "$AUTO_QUEUE" | jq -r '.count // "N/A"')
          echo "   Pending approval: $AUTO_COUNT"
          echo ""
          
          # Wade fulfillment queue
          echo "ğŸ‘¤ WADE FULFILLMENT QUEUE:"
          WADE_QUEUE=$(curl -s -X GET "${{ env.BACKEND_URL }}/wade/fulfillment-queue" --max-time 15 2>/dev/null || echo '{}')
          WADE_COUNT=$(echo "$WADE_QUEUE" | jq -r '.count // length // "N/A"')
          echo "   Items: $WADE_COUNT"
          echo ""
          
          # Social queue
          echo "ğŸ“± SOCIAL QUEUE:"
          # Social queue would need a GET endpoint
          echo "   (GET /social/queue not implemented)"
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 7: AME PITCH PROCESSING
  # Process queued AME pitches
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ame_pitches:
    name: ğŸ“§ AME Pitches
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'full' || github.event.inputs.mode == 'ame_pitches' }}
    
    steps:
      - name: ğŸ“§ Process AME Pitch Queue
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“§ AME PITCH PROCESSING"
          echo "   Autonomous Marketing Engine outreach"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # Process AME queue
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/ame/process-queue" \
            -H "Content-Type: application/json" \
            --max-time 60 2>/dev/null || echo '{"ok": false}')
          
          OK=$(echo "$RESPONSE" | jq -r '.ok // false')
          
          if [ "$OK" = "true" ]; then
            PROCESSED=$(echo "$RESPONSE" | jq -r '.processed // 0')
            SENT=$(echo "$RESPONSE" | jq -r '.sent // 0')
            echo "âœ… AME Pitches:"
            echo "   Processed: $PROCESSED"
            echo "   Sent: $SENT"
          else
            echo "âš ï¸ AME pitch queue processing not available"
          fi
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 8: DEAL GRAPH UPDATE (NEW in v4)
  # Update relationship graph with new intros
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deal_graph:
    name: ğŸ”— Deal Graph
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode == 'full' }}
    
    steps:
      - name: ğŸ”— Find Intro Opportunities
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ”— DEAL GRAPH - RELATIONSHIP INTELLIGENCE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
          # This is included in /autonomous/full-cycle
          RESPONSE=$(curl -s -X POST "${{ env.BACKEND_URL }}/autonomous/full-cycle" \
            -H "Content-Type: application/json" \
            --max-time 120 || echo '{"ok": false}')
          
          INTROS=$(echo "$RESPONSE" | jq -r '.results.intros // {}')
          
          if [ "$INTROS" != "{}" ] && [ "$INTROS" != "null" ]; then
            COUNT=$(echo "$INTROS" | jq -r '.count // 0')
            echo "âœ… INTRO OPPORTUNITIES: $COUNT"
            
            # Show top intros if available
            echo "$INTROS" | jq -r '.opportunities[:3][]? | "   - \(.connector // "unknown") â†’ \(.target // "unknown") (\(.intro_type // "intro"))"' 2>/dev/null || true
          else
            echo "âš ï¸ Deal graph not available in this run"
          fi
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 9: SUMMARY
  # Post-run summary of all actions
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: ğŸ“ Run Summary
    runs-on: ubuntu-latest
    needs: [discovery, arbitrage, signals, social, health, ame_pitches, deal_graph]
    if: always()
    
    steps:
      - name: ğŸ“ Generate Run Summary
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“ AIGENTSY AUTONOMOUS RUN SUMMARY v4"
          echo "   77 files | 143+ systems | ~95,000 lines"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ• Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ”§ Mode: ${{ github.event.inputs.mode || 'full' }}"
          echo ""
          echo "ğŸ“Š DISCOVERY RESULTS:"
          echo "   Opportunities: ${{ needs.discovery.outputs.total_discovered || '0' }}"
          echo "   Total Value: \$${{ needs.discovery.outputs.total_value || '0' }}"
          echo "   Executed: ${{ needs.discovery.outputs.total_executed || '0' }}"
          echo "   User Routed: ${{ needs.discovery.outputs.user_routed || '0' }}"
          echo "   AiGentsy Routed: ${{ needs.discovery.outputs.aigentsy_routed || '0' }}"
          echo ""
          echo "âœ… JOB STATUS:"
          echo "   Discovery: ${{ needs.discovery.result || 'skipped' }}"
          echo "   Arbitrage: ${{ needs.arbitrage.result || 'skipped' }}"
          echo "   Signals: ${{ needs.signals.result || 'skipped' }}"
          echo "   Social: ${{ needs.social.result || 'skipped' }}"
          echo "   Health: ${{ needs.health.result || 'skipped' }}"
          echo "   AME Pitches: ${{ needs.ame_pitches.result || 'skipped' }}"
          echo "   Deal Graph: ${{ needs.deal_graph.result || 'skipped' }}"
          echo ""
          echo "ğŸ”— Backend: ${{ env.BACKEND_URL }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "              AIGENTSY v4 RUN COMPLETE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
